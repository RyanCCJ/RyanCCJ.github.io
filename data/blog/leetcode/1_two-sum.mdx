---
title: 'LeetCode 1. Two Sum'
date: '2024-04-15'
tags: ['LeetCode']
draft: true
summary: 'Hash Table (Easy)'
---

## Description

[![](https://img.shields.io/badge/Easy-green)](https://leetcode.com/problems/two-sum/)

Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.


Example 1:
```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

Example 2:
```
Input: nums = [3,2,4], target = 6
Output: [1,2]
```

Example 3:
```
Input: nums = [3,3], target = 6
Output: [0,1]
```

### Constraints:

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **Only one valid answer exists.**

**Follow-up:** Can you come up with an algorithm that is less than `O(n2)` time complexity?

## Python

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic = {}
        for i in range(len(nums)):
            diff  = target - nums[i]
            if diff in dic:
                return [ dic[diff], i]
            else:
                dic[ nums[i] ] = i
```
- Time Complexity: O(n)
- Space Complexity: O(n)
- Run Time: 62ms (55.11%)
- Memory: 17.88MB (16.29%)

## C
**Brute Force**
```c
int* twoSum(int* nums, int numsSize, int target, int* returnSize){
    
    *returnSize = 2;
    bool flag = false;
    int* ans = (int*)malloc(*returnSize * sizeof(int));
    for(int i=0; i<numsSize; i++){
        for(int j=i+1; j<numsSize; j++){
            if((nums[i]+nums[j])==target){
                ans[0] = i;
                ans[1] = j;
                flag = true;
                break;
            }
        }
        if(flag) break;
    }
    return ans;
}
```
- Time Complexity: O(n^2)
- Space Complexity: O(1)
- Run Time: 76ms (84.58%)
- Memory: 6.21MB (46.31%)
